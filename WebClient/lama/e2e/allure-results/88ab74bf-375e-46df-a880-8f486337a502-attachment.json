{
  "script": "return (function isElementDisplayed(element) {\n  function nodeIsElement(node) {\n    if (!node) return false;\n\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE:\n      case Node.DOCUMENT_NODE:\n      case Node.DOCUMENT_FRAGMENT_NODE:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  function parentElementForElement(element) {\n    if (!element) return null;\n    return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n  }\n\n  function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n    for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) if (predicate(node)) return node;\n\n    return null;\n  }\n\n  function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n    for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) if (predicate(element)) return element;\n\n    return null;\n  }\n\n  function cascadedStylePropertyForElement(element, property) {\n    if (!element || !property) return null;\n    let computedStyle = window.getComputedStyle(element);\n    let computedStyleProperty = computedStyle.getPropertyValue(property);\n    if (computedStyleProperty && computedStyleProperty !== 'inherit') return computedStyleProperty; // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n    // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n    // Fall back to the first non-'inherit' value found in an ancestor.\n    // In any case, getPropertyValue will not return 'initial'.\n    // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n    // I think all important non-inheritable properties (width, height, etc.)\n    // for our purposes here are specially resolved, so this may not be an issue.\n    // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n\n    let parentElement = parentElementForElement(element);\n    return cascadedStylePropertyForElement(parentElement, property);\n  }\n\n  function elementSubtreeHasNonZeroDimensions(element) {\n    let boundingBox = element.getBoundingClientRect();\n    if (boundingBox.width > 0 && boundingBox.height > 0) return true; // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n\n    if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n      let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n      return !!strokeWidth && parseInt(strokeWidth, 10) > 0;\n    }\n\n    let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n    if (cascadedOverflow === 'hidden') return false; // If the container's overflow is not hidden and it has zero size, consider the\n    // container to have non-zero dimensions if a child node has non-zero dimensions.\n\n    return Array.from(element.childNodes).some(childNode => {\n      if (childNode.nodeType === Node.TEXT_NODE) return true;\n      if (nodeIsElement(childNode)) return elementSubtreeHasNonZeroDimensions(childNode);\n      return false;\n    });\n  }\n\n  function elementOverflowsContainer(element) {\n    let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n    if (cascadedOverflow !== 'hidden') return false; // FIXME: this needs to take into account the scroll position of the element,\n    // the display modes of it and its ancestors, and the container it overflows.\n    // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n\n    return true;\n  }\n\n  function isElementSubtreeHiddenByOverflow(element) {\n    if (!element) return false;\n    if (!elementOverflowsContainer(element)) return false;\n    if (!element.childNodes.length) return false; // This element's subtree is hidden by overflow if all child subtrees are as well.\n\n    return Array.from(element.childNodes).every(childNode => {\n      // Returns true if the child node is overflowed or otherwise hidden.\n      // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n      if (!nodeIsElement(childNode)) return true;\n      if (!elementSubtreeHasNonZeroDimensions(childNode)) return true; // Recurse.\n\n      return isElementSubtreeHiddenByOverflow(childNode);\n    });\n  } // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n  // When the W3C specification's algorithm stabilizes, we should implement that.\n  // If this command is misdirected to the wrong document, treat it as not shown.\n\n\n  if (!document.contains(element)) return false; // Special cases for specific tag names.\n\n  switch (element.tagName.toUpperCase()) {\n    case 'BODY':\n      return true;\n\n    case 'SCRIPT':\n    case 'NOSCRIPT':\n      return false;\n\n    case 'OPTGROUP':\n    case 'OPTION':\n      {\n        // Option/optgroup are considered shown if the containing <select> is shown.\n        let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, e => e.tagName.toUpperCase() === 'SELECT');\n        return isElementDisplayed(enclosingSelectElement);\n      }\n\n    case 'INPUT':\n      // <input type=\"hidden\"> is considered not shown.\n      if (element.type === 'hidden') return false;\n      break;\n    // case 'MAP':\n    // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n\n    default:\n      break;\n  }\n\n  if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') return false;\n  let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, e => {\n    return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n  });\n  let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, e => {\n    return cascadedStylePropertyForElement(e, 'display') === 'none';\n  });\n  if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) return false;\n  if (!elementSubtreeHasNonZeroDimensions(element)) return false;\n  if (isElementSubtreeHiddenByOverflow(element)) return false;\n  return true;\n}).apply(null, arguments)",
  "args": [
    {
      "element-6066-11e4-a52e-4f735466cecf": "bdf9a2c3-4397-4be7-bca1-4850591ff922",
      "ELEMENT": "bdf9a2c3-4397-4be7-bca1-4850591ff922"
    }
  ]
}